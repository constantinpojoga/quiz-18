

//gradient
@mixin gradient($degree, $topColor, $topValue, $bottomColor, $bottomValue) {
    background-color: $topColor;
    background-image: linear-gradient($degree, $topColor $topValue, $bottomColor $bottomValue);
}

@mixin clearfix {
    &:before,
    &:after {
        content: " ";
        display: table;
    }
    &:after {
        clear: both;
    }
}

//opacity
@mixin opacity($value) {
    opacity: $value;
    filter: alpha(opacity=$value*100);
    -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity="$value*100")";
}

//hide text
@mixin hide-text {
    overflow: hidden;
    text-indent: -9999px;
    display: block;
}

// fix for ipad 7 (triggers on all ipads that match the below device height and width)
@mixin ipad7-vh-fix($percentHeight:100) {
    $percentHeight: $percentHeight / 100;
    // ipad portrait
    @media all and (device-width: 768px) and (device-height: 1024px) and (orientation: portrait) {
        height: 1024px * $percentHeight;
    }
    // ipad landscape
    @media all and (device-width: 768px) and (device-height: 1024px) and (orientation:landscape) {
        height: 768px * $percentHeight;
    }
}

// bp (feature, breakpoint[, OPTIONAL_WITHIN_MAX_VALUE]} mixin
// these mixins build breakpoints mixins based off of the breakpoint matrix in the main configuration file
//      or from a custom number entered into the mixin
//
// Paramters:
//      - $feature: ["min, "max", "within"] - string indicating whether to declare min-width, max-width or within a min and max on the media query
//      - $breakpoint: ["md", 1000px ] - either a string referenceing a key value from $breakpoints or a number (with pixel units)
//
// usage example:
//
//      // pull in the values from the already established 'mdd' key in the $breakpoints map
//      // uses min-width in the media query
//      .someclass {
//          @include bp('min', 'md') {
//              some: style;
//          }
//          @include bp('max', 'sm') {
//              anther: style;
//          }
//      }
//
//      // use a custom breakpoint
//      // uses max-width in the media query
//      .someclass {
//          @include bp('max', 500px) {
//              some: style;
//          }
//          @include bp('min', 1000px) {
//              some: style;
//          }
//      }
//
//      // use the within feature with custom values or breakpoint variables
//      .someclass {
//          @include bp('within', 'md') {
//              some: style;
//          }
//          @include bp('within', 1000px, 1200px) {
//              some: style;
//          }
//      }
//
// $feature     - 'min', 'max', 'within'
// $width       - 'xs', 'sm', 'md', 'lg', 'xl', 'xxl', 'xxxl', 1200px
// $within_max  - 1200px
$bpFeatures: "min",
"max",
"within";
@mixin bp($feature, $width:"", $within_max:"") {
    $stringWidth: false;
    $within_max_set: false;
    $mapWidth: null !default;
    $maxWidth: null !default;
    $minWidth: null !default;
    //if width is not blank and string, get values from $breakpoints
    @if not ($width=="") and (type-of($width)=="string") {
        @if map-has-key($bp, $width) {
            $mapWidth: map-get($bp, $width);
            $maxWidth: map-get($mapWidth, "max");
            $minWidth: map-get($mapWidth, "min");
            $stringWidth: true;
        }
    }
    //check if $within_max set and is number
    @if not($within_max=="") and type-of($within_max=="number") {
        $within_max_set: true;
    }
    // if $feature is a string
    @if type-of($feature)=="string" {
        //lowercase the string
        $feature: to-lower-case($feature);
        //if $feature within $bpFeatures
        @if index($bpFeatures, $feature) {
            // if $feature value is 'within'
            @if $feature=="within" {
                //if width is not string and $within_max has a number value
                @if (not $stringWidth and $within_max_set) or ($stringWidth and not $within_max_set) {
                    @if not $stringWidth {
                        $maxWidth: $within_max;
                        $minWidth: $width;
                    }
                    @if $maxWidth < $minWidth {
                        @error "SASS Mixin bp(): Breakpoint min and max not in correct order. Should follow: bp('within', $min, $max)";
                    }
                    @media only screen and (min-width: $minWidth) and (max-width: $maxWidth) {
                        @content;
                    }
                    //if width is string and no within max set
                }
                @else {
                    @error "SASS Mixin bp(): Width values incorrect. Values need to be within $breakpoints or a min and max number.";
                }
            }
            @else {
                @if $within_max_set {
                    @warn "SASS Mixin bp(): $within_max value not set."
                }
                @if not $stringWidth {
                    $minWidth: $width;
                    $maxWidth: $width;
                }
                @if $feature=="min" {
                    @media only screen and (min-width: $minWidth) {
                        @content;
                    }
                }
                @else if $feature=="max" {
                    @media only screen and (max-width: $maxWidth) {
                        @content;
                    }
                }
            }
        }
    }
    @else {
        @error "SASS Mixin bp(): $feature paramater not string or within $bpFeatures.";
    }
}

//container
@mixin container($maxContentWidth: 1200px, $maxContentLeftSpacing: 276px, $contentBreakpoint: 1312px, $contentBreakpointValue: 1312) {
  width: 100%;
  max-width: $maxContentWidth;
  margin: 0;
  position: relative;
  padding: 0 $bodySpacing;
  @include bp("min", 'md') {
      margin: 0 auto;
  }
}

@mixin full-bleed($maxBreakpoint: 'sm') {
    @include bp('max',$maxBreakpoint) {
        margin-left: -$bodySpacing;
        margin-right: -$bodySpacing;
        width: calc(100% + (#{$bodySpacing}*2));
    }
}

@mixin image() {
    max-width: 100%;
    height: auto;
    img {
        max-width: 100%;
        height: auto;
    }
    &.no-max img {
        width: 100%;
    }
}

@mixin sr-only() {
    position: absolute;
    left: -10000px;
    top: auto;
    width: 1px;
    height: 1px;
    overflow: hidden;
}

@mixin list-none() {
    list-style: none;
    padding: 0;
    margin: 0;
}

/*
	Generates basic rules for a font declaration as rem and em for specified px values
	$fontSize: int //provided size, in px
	$lineHeight: int //provided line height, in px
	$letterSpacing: string/int/dec //provided letter spacing in em/px
*/

@mixin font-sizing($fontSize, $lineHeight, $letterSpacing: false) {
    font-size: ($fontSize/$baseFontSize) * 1rem;
    line-height: ($lineHeight/$fontSize) * 1em;
    @if $letterSpacing {
        letter-spacing: $letterSpacing;
    }
}


/*
	Generates rules and mobile-first media queries for a basic one-breakpoint font style, in rems and em
	$fontSize: int //provided size, in px
	$lineHeight: int //provided line height, in px
	$letterSpacing: string/int/dec //provided letter spacing in em/px
*/

@mixin responsive-font-sizing($desktopFontSize, $desktopLineHeight, $desktopLetterSpacing, $breakPoint, $mobileFontSize, $mobileLineHeight, $mobileLetterSpacing) {
    @include font-sizing($mobileFontSize, $mobileLineHeight, $mobileLetterSpacing);
    @media screen and (min-width: $breakPoint * 1px) {
        @include font-sizing($desktopFontSize, $desktopLineHeight, $desktopLetterSpacing);
    }
}

/*
	Pan Tumor & Tumor Specific Navigation (Desktop)

*/
//Fluid Test
// @include poly("font-size", ( 375px: 15px, 767px: 30px));
@mixin poly($property, $map) {
	// Get the number of provided breakpoints
	$length: length(map-keys($map));

	// Error if the number of breakpoints is < 2
	@if ($length < 2) {
	  @error "poly() $map requires at least values";
	}

	// Sort the map by viewport width (key)
	$map: map-sort($map);
	$keys: map-keys($map);

	#{$property}: linear-interpolation(
	  (
		nth($keys, 1): map-get($map, nth($keys, 1)),
		nth($keys, 2): map-get($map, nth($keys, 2))
	  )
	);

	@for $i from 1 through ($length - 1) {
	  @media (min-width: nth($keys,$i)) {
		#{$property}: linear-interpolation(

		  (
			nth($keys, $i): map-get($map, nth($keys, $i)),
			nth($keys,  ($i+1)): map-get($map, nth($keys,  ($i + 1)))
		  )
		);
	  }
	}

	@media (min-width: nth($keys,$length)) {
	  #{$property}: map-get($map, nth($keys, $length));
	}
  }

  @function linear-interpolation($map) {
	$keys: map-keys($map);
	@if (length($keys) != 2) {
	  @error "linear-interpolation() $map must be exactly 2 values";
	}
	// The slope
	$m: (map-get($map, nth($keys, 2)) - map-get($map, nth($keys, 1)))/(
		nth($keys, 2) - nth($keys, 1)
	  );

	// The y-intercept
	$b: map-get($map, nth($keys, 1)) - $m * nth($keys, 1);

	// Determine if the sign should be positive or negative
	$sign: "+";
	@if ($b < 0) {
	  $sign: "-";
	  $b: abs($b);
	}
	@return calc(#{$m*100}vw #{$sign} #{$b});
  }

  @function list-sort($list) {
	$sortedlist: ();
	@while length($list) > 0 {
	  $value: nth($list, 1);
	  @each $item in $list {
		@if $item < $value {
		  $value: $item;
		}
	  }
	  $sortedlist: append($sortedlist, $value, 'space');
	  $list: list-remove($list, index($list, $value));
	}
	@return $sortedlist;
  }

  @function map-sort($map) {
	$keys: list-sort(map-keys($map));
	$sortedMap: ();
	@each $key in $keys {
	  $sortedMap: map-merge($sortedMap,  ($key: map-get($map, $key)));
	}
	@return $sortedMap;
  }

  @function list-remove($list, $index) {
	$newList: ();
	@for $i from 1 through length($list) {
	  @if $i != $index {
		$newList: append($newList, nth($list, $i), 'space');
	  }
	}
	@return $newList;
  }


